https://ru.wikibrief.org/wiki/Bloom_filter
https://habr.com/en/company/qrator/blog/559818/

1) Создайте фильтр Блума. Массив на 50 бит. Покажите коллизи в списке имён.
2) Создайте каскадный фильтр Блума. 2 слоя по 50 бит. Коллизии перенесите на второй слой.
3) Код должен проверить наличие "2:Frank" в каскадном фильтре.
4) Создайте 3 вероятностных счётчика: a, b, c.
Инкремент делайте раз в 1мс с вероятностью 1/2 1/10 1/100
5) Моррис с полураспадом. 1 раз в секунду делите пополам счётчики.

Пояснения:
1) Дан список из 25 имён. К имени прибавить "1", взять sha256, sha_to_int%50,
бит установить в true. Прибавить к имени "2" и повторить. Это будет 1-ый слой фильтра.

2) Додумайтесь, как узнать для каких имён коллизии. Потом аналогично для этих имён
прибавьте "3" и "4" для второго слоя.

3) Строку "2:Frank" разбиваете по ":", проверяете "Frank" на первом слое,
если он там есть, то проверяете на втором слое.

4) Создаём 3 атомика. В треде раз в 1мс делаем инкремент с вероятностью.
А в main раз в 1сек принтуем счётчики.

5) В main раз в 1сек делим счётчики на 2 и принтуем. Как показано ниже.


PS:
1) До этого мы искали "in" в файлах. Благодаря фильтру, можем искать в меньшем количестве файлов.
Почитайте раздел "Примеры" в https://ru.wikibrief.org/wiki/Bloom_filter
2) А что, если мы заранее знаем список имён для проверки и только их будем проверять?!
Тогда можно сделать каскады и однозначно проверять наличие. Этим алгоритмом русские ускорили софт
для биоинформатиков.
3) И как следствие, надо помнить до какого каскада надо спускаться.
4-5) Когда писали отказоустойчивый распределённый key-value, то нагрузку разбрасывали поровну на реплики.
Но что если надо считать количество обработанных запросов и раздавать запросы исходя из загруженности,
считая время под нагрузкой. Можно иметь производительный сервер с ssd и слабый с hdd. При этом "справедливо"
распределять нагрузку!



#include <chrono>
#include <thread>
#include <stdlib.h>
#include <string.h>
#include <sstream>
#include <cmath>
#include <vector>
#include <atomic>
#include <cstdlib>
#include <iostream>
#include <ctime>

unsigned int sha_to_int(string sha){
  unsigned int int_sha = 0;
  int num_char;
  for(int i=0;i<8;++i){
    num_char = (sha[i] << 0)-48;
    if(num_char > 10){
      num_char -= 39;
    }
    int_sha += num_char * pow(16,i);
    //cout<<i<<": "<<num_char<<endl;
  }
  //cout<<int_sha<<endl;
  return int_sha;
}

cout<<sha_to_int(sha)%100<<endl;

const int N = 2;
const int M = 50;
bool bloom[N][M]{};

atomic<int> a{0};
atomic<int> b{0};
atomic<int> c{0};

//////////////////////////////////////////
1:Adams
1:Baker
1:Clark
1:Davis
1:Evans
2:Frank
1:Ghosh
2:Hills
1:Irwin
1:Jones
1:Klein
2:Lopez
1:Mason
1:Nalty
1:Ochoa
1:Patel
1:Quinn
2:Reily
1:Smith
1:Trott
1:Usman
2:Valdo
1:White
1:Xiang
1:Yakub
0 0 0
397 71 11
596 105 13
717 134 11
773 139 22
776 172 19
822 168 16
816 163 13
799 157 14
814 152 16
752 143 16
795 159 17
823 160 17




